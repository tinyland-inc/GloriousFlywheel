# Attic Cache - GitLab CI/CD Pipeline (Bates ILS)
# ================================================
#
# Deploys Attic Nix binary cache to Bates Kubernetes clusters:
#   - beehive: Development and merge request reviews
#   - rigel: Staging and production deployments
#
# Authentication: Disabled (public cache on internal Bates network)
# Storage: MinIO (self-managed S3-compatible storage)
#
# Deployment Flow:
#   - Feature/MR branches: Review environment on beehive
#   - main branch: Auto-deploy to staging on rigel
#   - Semver tags (v*.*.*): Production deploy on rigel
#
# CI/CD Variables:
#   With MinIO (default): No S3 variables required
#   With External S3: S3_ENDPOINT, S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY, S3_BUCKET_NAME
#
# GitLab Kubernetes Agent:
#   Authorization via group: bates-ils/people/jsullivan2
#   beehive agent: bates-ils/projects/kubernetes/gitlab-agents:beehive
#   rigel agent: bates-ils/projects/kubernetes/gitlab-agents:rigel

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/

stages:
  - validate
  - build
  - test
  - deploy
  - verify

variables:
  # Namespace configuration
  NAMESPACE: "attic-cache"
  FIXED_SUBDOMAIN: "attic-cache"

  # Beehive cluster (review/dev)
  REVIEW_CONTEXT: "bates-ils/projects/kubernetes/gitlab-agents:beehive"
  KUBE_INGRESS_BASE_DOMAIN: beehive.bates.edu
  KUBE_CONTEXT: $REVIEW_CONTEXT

  # Rigel cluster (staging/production)
  STAGING_PROD_CONTEXT: "bates-ils/projects/kubernetes/gitlab-agents:rigel"
  STAGING_KUBE_INGRESS_BASE_DOMAIN: rigel.bates.edu

  # Namespace per environment
  REVIEW_NS: ${NAMESPACE}-review
  STAGING_NS: ${NAMESPACE}-staging
  PROD_NS: ${NAMESPACE}

  # OpenTofu settings
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

  # Nix configuration
  NIX_CONFIG: |
    experimental-features = nix-command flakes
    accept-flake-config = true

  # Attic cache configuration (auth-free)
  ATTIC_SERVER: "https://${FIXED_SUBDOMAIN}.${KUBE_INGRESS_BASE_DOMAIN}"
  ATTIC_CACHE: "main"

  # Bazel remote cache (cluster-internal, set when bazel-cache is deployed)
  # Default endpoint assumes beehive deployment with attic-cache-dev namespace
  BAZEL_REMOTE_CACHE: "grpc://bazel-cache.attic-cache-dev.svc.cluster.local:9092"

  # Disable unused AutoDevOps features
  TEST_DISABLED: "1"
  CODE_QUALITY_DISABLED: "1"
  POSTGRES_ENABLED: "false"

  # Kubernetes Agent warning suppress
  KUBERNETES_AGENT_WARNING_SUPPRESS: "true"

# Default job configuration
default:
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  interruptible: true
  tags:
    - kubernetes

# Include templates and job definitions
include:
  # Security scanning
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  # OpenTofu base templates (provides .tofu_with_k8s_tools)
  - local: ".gitlab/ci/templates/tofu-base.gitlab-ci.yml"
  # OpenTofu plan and apply jobs
  - local: ".gitlab/ci/jobs/tofu-plan.gitlab-ci.yml"
  - local: ".gitlab/ci/jobs/tofu-apply.gitlab-ci.yml"
  # Nix validation and build jobs
  - local: ".gitlab/ci/jobs/nix-check.gitlab-ci.yml"
  - local: ".gitlab/ci/jobs/nix-build.gitlab-ci.yml"
  # Bazel validation and build jobs (with remote cache)
  - local: ".gitlab/ci/jobs/bazel-build.gitlab-ci.yml"

# ==============================================================================
# Verify Stage - Health Checks
# ==============================================================================

# ==============================================================================
# Debug Job - Diagnose cluster state (manual trigger)
# ==============================================================================

debug:cluster:beehive:
  stage: verify
  extends: .tofu_with_k8s_tools
  when: manual
  allow_failure: true
  variables:
    KUBE_CONTEXT: "bates-ils/projects/kubernetes/gitlab-agents:beehive"
    DEBUG_NAMESPACE: "attic-cache-review"
  script:
    - |
      echo "=== Beehive Cluster Diagnostics ==="
      echo "Context: ${KUBE_CONTEXT}"
      echo "Namespace: ${DEBUG_NAMESPACE}"
      echo ""

      echo "=== Namespace Check ==="
      kubectl get namespace ${DEBUG_NAMESPACE} 2>/dev/null || echo "Namespace doesn't exist yet"

      echo ""
      echo "=== All Pods in Namespace ==="
      kubectl get pods -n ${DEBUG_NAMESPACE} -o wide 2>/dev/null || echo "No pods or namespace not found"

      echo ""
      echo "=== Pod Events ==="
      kubectl get events -n ${DEBUG_NAMESPACE} --sort-by='.lastTimestamp' 2>/dev/null | tail -30 || echo "No events"

      echo ""
      echo "=== Deployments ==="
      kubectl get deployments -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No deployments"

      echo ""
      echo "=== StatefulSets ==="
      kubectl get statefulsets -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No statefulsets"

      echo ""
      echo "=== Services ==="
      kubectl get services -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No services"

      echo ""
      echo "=== PVCs ==="
      kubectl get pvc -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No PVCs"

      echo ""
      echo "=== ConfigMaps ==="
      kubectl get configmaps -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No configmaps"

      echo ""
      echo "=== Secrets (names only) ==="
      kubectl get secrets -n ${DEBUG_NAMESPACE} 2>/dev/null || echo "No secrets"

      echo ""
      echo "=== Describe Failing Pods ==="
      for pod in $(kubectl get pods -n ${DEBUG_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}' 2>/dev/null); do
        echo "--- Pod: $pod ---"
        kubectl describe pod $pod -n ${DEBUG_NAMESPACE} | tail -50
        echo ""
      done

      echo ""
      echo "=== Check Operators ==="
      echo "MinIO Operator:"
      kubectl get pods -n minio-operator 2>/dev/null || echo "MinIO Operator namespace not found"
      echo ""
      echo "CNPG Operator:"
      kubectl get pods -n cnpg-system 2>/dev/null || echo "CNPG namespace not found"

# Auto-triggered debug on MR to capture cluster state
debug:auto:beehive:
  stage: verify
  extends: .tofu_with_k8s_tools
  needs:
    - job: tofu:apply:review
      optional: true
  allow_failure: true
  variables:
    KUBE_CONTEXT: "bates-ils/projects/kubernetes/gitlab-agents:beehive"
    DEBUG_NAMESPACE: "attic-cache-review"
  script:
    - |
      echo "=== Auto Debug: Beehive Cluster ==="
      echo "Namespace: ${DEBUG_NAMESPACE}"
      echo ""

      echo "=== Storage Classes ==="
      kubectl get sc || echo "No storage classes"

      echo ""
      echo "=== PVCs in Namespace ==="
      kubectl get pvc -n ${DEBUG_NAMESPACE} -o wide || echo "No PVCs"

      echo ""
      echo "=== Describe Pending PVCs ==="
      for pvc in $(kubectl get pvc -n ${DEBUG_NAMESPACE} -o jsonpath='{.items[?(@.status.phase!="Bound")].metadata.name}' 2>/dev/null); do
        echo "--- PVC: $pvc ---"
        kubectl describe pvc $pvc -n ${DEBUG_NAMESPACE} | tail -20
      done

      echo ""
      echo "=== Pods ==="
      kubectl get pods -n ${DEBUG_NAMESPACE} -o wide || echo "No pods"

      echo ""
      echo "=== Describe Pending/Failed Pods ==="
      for pod in $(kubectl get pods -n ${DEBUG_NAMESPACE} --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}' 2>/dev/null); do
        echo "--- Pod: $pod ---"
        kubectl describe pod $pod -n ${DEBUG_NAMESPACE} 2>&1 | grep -A 30 "Events:" || kubectl describe pod $pod -n ${DEBUG_NAMESPACE} | tail -30
      done

      echo ""
      echo "=== Recent Events ==="
      kubectl get events -n ${DEBUG_NAMESPACE} --sort-by='.lastTimestamp' 2>/dev/null | tail -40 || echo "No events"

      echo ""
      echo "=== MinIO Tenant Status ==="
      kubectl get tenant -n ${DEBUG_NAMESPACE} -o wide 2>/dev/null || echo "No MinIO tenant"

      echo ""
      echo "=== CNPG Cluster Status ==="
      kubectl get cluster -n ${DEBUG_NAMESPACE} -o wide 2>/dev/null || echo "No CNPG cluster"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

verify:health:review:
  stage: verify
  image: curlimages/curl:latest
  needs:
    - job: tofu:apply:review
      optional: true
  variables:
    HEALTH_MAX_ATTEMPTS: "15"
    HEALTH_INITIAL_DELAY: "30"
    HEALTH_MAX_DELAY: "60"
  script:
    - |
      HEALTH_URL="https://${FIXED_SUBDOMAIN}-${CI_COMMIT_REF_SLUG}.${KUBE_INGRESS_BASE_DOMAIN}/nix-cache-info"
      echo "=== Health Check (Review Environment) ==="
      echo "URL: ${HEALTH_URL}"
      echo "Max attempts: ${HEALTH_MAX_ATTEMPTS}, Initial delay: ${HEALTH_INITIAL_DELAY}s"
      echo ""

      DELAY=${HEALTH_INITIAL_DELAY}
      for i in $(seq 1 ${HEALTH_MAX_ATTEMPTS}); do
        echo "[$(date '+%H:%M:%S')] Attempt ${i}/${HEALTH_MAX_ATTEMPTS}..."
        HTTP_CODE=$(curl -sSo /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$HEALTH_URL" 2>/dev/null || echo "000")

        if [ "$HTTP_CODE" = "200" ]; then
          echo ""
          echo "=== Health check PASSED (HTTP $HTTP_CODE) ==="
          curl -sS "$HEALTH_URL"
          exit 0
        fi

        echo "  HTTP $HTTP_CODE - waiting ${DELAY}s..."
        sleep ${DELAY}

        # Exponential backoff
        DELAY=$((DELAY + 15))
        [ $DELAY -gt ${HEALTH_MAX_DELAY} ] && DELAY=${HEALTH_MAX_DELAY}
      done

      echo ""
      echo "=== Health check FAILED after ${HEALTH_MAX_ATTEMPTS} attempts ==="
      echo "Operators may still be initializing. The deployment will become ready once dependencies are available."
      exit 1
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: true

verify:health:staging:
  stage: verify
  image: curlimages/curl:latest
  needs:
    - job: tofu:apply:staging
      optional: true
  variables:
    HEALTH_MAX_ATTEMPTS: "15"
    HEALTH_INITIAL_DELAY: "30"
    HEALTH_MAX_DELAY: "60"
  script:
    - |
      HEALTH_URL="https://${FIXED_SUBDOMAIN}.${STAGING_KUBE_INGRESS_BASE_DOMAIN}/nix-cache-info"
      echo "=== Health Check (Staging Environment) ==="
      echo "URL: ${HEALTH_URL}"
      echo ""

      DELAY=${HEALTH_INITIAL_DELAY}
      for i in $(seq 1 ${HEALTH_MAX_ATTEMPTS}); do
        echo "[$(date '+%H:%M:%S')] Attempt ${i}/${HEALTH_MAX_ATTEMPTS}..."
        HTTP_CODE=$(curl -sSo /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$HEALTH_URL" 2>/dev/null || echo "000")

        if [ "$HTTP_CODE" = "200" ]; then
          echo ""
          echo "=== Health check PASSED (HTTP $HTTP_CODE) ==="
          curl -sS "$HEALTH_URL"
          exit 0
        fi

        echo "  HTTP $HTTP_CODE - waiting ${DELAY}s..."
        sleep ${DELAY}

        DELAY=$((DELAY + 15))
        [ $DELAY -gt ${HEALTH_MAX_DELAY} ] && DELAY=${HEALTH_MAX_DELAY}
      done

      echo ""
      echo "=== Health check FAILED after ${HEALTH_MAX_ATTEMPTS} attempts ==="
      exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

verify:health:production:
  stage: verify
  image: curlimages/curl:latest
  needs:
    - job: tofu:apply:production
      optional: true
  variables:
    HEALTH_MAX_ATTEMPTS: "10"
    HEALTH_INITIAL_DELAY: "15"
    HEALTH_MAX_DELAY: "30"
  script:
    - |
      HEALTH_URL="https://${FIXED_SUBDOMAIN}.${STAGING_KUBE_INGRESS_BASE_DOMAIN}/nix-cache-info"
      echo "=== Health Check (Production Environment) ==="
      echo "URL: ${HEALTH_URL}"
      echo ""

      DELAY=${HEALTH_INITIAL_DELAY}
      for i in $(seq 1 ${HEALTH_MAX_ATTEMPTS}); do
        echo "[$(date '+%H:%M:%S')] Attempt ${i}/${HEALTH_MAX_ATTEMPTS}..."
        HTTP_CODE=$(curl -sSo /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$HEALTH_URL" 2>/dev/null || echo "000")

        if [ "$HTTP_CODE" = "200" ]; then
          echo ""
          echo "=== Health check PASSED (HTTP $HTTP_CODE) ==="
          curl -sS "$HEALTH_URL"
          exit 0
        fi

        echo "  HTTP $HTTP_CODE - waiting ${DELAY}s..."
        sleep ${DELAY}

        DELAY=$((DELAY + 15))
        [ $DELAY -gt ${HEALTH_MAX_DELAY} ] && DELAY=${HEALTH_MAX_DELAY}
      done

      echo ""
      echo "=== Health check FAILED after ${HEALTH_MAX_ATTEMPTS} attempts ==="
      exit 1
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
  allow_failure: true
