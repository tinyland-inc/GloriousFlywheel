# OpenTofu Plan Jobs
#
# Generates execution plans for infrastructure changes.
# - Validate: Runs on all branches and MRs
# - Plan: Generates detailed execution plan with artifacts
# - Plan artifacts are used by apply jobs
#
# Uses auth-free mode with GitLab K8s Agent

# ==============================================================================
# Validation Job
# ==============================================================================

# Uses .tofu_gitlab_backend (not .tofu_with_k8s_tools) since validation
# doesn't need kubectl - it only validates tofu syntax
tofu:validate:
  extends: .tofu_gitlab_backend
  stage: validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  variables:
    TF_STATE_NAME: "attic-${CI_ENVIRONMENT_SLUG:-production}"
  script:
    - |
      echo "=== OpenTofu Validate ==="
      cd tofu/stacks/attic

      echo "Initializing OpenTofu..."
      tofu init -backend=false

      echo ""
      echo "Validating configuration..."
      tofu validate

      echo ""
      echo "Formatting check..."
      tofu fmt -check -recursive || {
        echo "WARNING: Some files are not formatted. Run 'tofu fmt -recursive' locally."
      }

      echo ""
      echo "Validation complete"

# ==============================================================================
# Plan Jobs
# ==============================================================================

# Base plan template (GitLab K8s Agent)
.tofu_plan_base:
  extends: .tofu_with_k8s_tools
  stage: build
  needs:
    - job: tofu:validate
      artifacts: false
      optional: true # Don't block plan if validate fails
  script:
    - |
      echo "=== OpenTofu Plan (${TF_ENVIRONMENT:-default}) ==="
      cd tofu/stacks/attic

      # Configure GitLab state backend
      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      echo "State: ${TF_HTTP_ADDRESS}"

      echo ""
      echo "Initializing OpenTofu..."
      tofu init

      echo ""
      echo "Generating plan..."

      # Load environment-specific tfvars file path
      VAR_FILE="${TF_VAR_tfvars_file:-beehive.tfvars}"

      # Build var flags: var-file FIRST, then explicit -var flags override
      # This allows CI variables to override tfvars defaults
      VAR_FLAGS=()

      # Load environment-specific tfvars FIRST (so -var can override)
      if [ -f "$VAR_FILE" ]; then
        echo "Loading $VAR_FILE"
        VAR_FLAGS+=(-var-file="$VAR_FILE")
      fi

      # Only pass S3 vars if MinIO is disabled (check tfvars)
      # When use_minio=true, MinIO provides S3-compatible storage internally
      if [ -f "$VAR_FILE" ] && grep -q 'use_minio.*=.*true' "$VAR_FILE"; then
        echo "MinIO enabled - S3 variables not required"
      else
        echo "External S3 mode - passing S3 variables"
        VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      # Explicit -var flags AFTER var-file (these override tfvars)
      VAR_FLAGS+=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=${TF_VAR_namespace:-attic-cache}"
        -var="environment=${TF_VAR_environment:-production}"
        -var="use_cnpg_postgres=true"
      )

      # For review environments, override ingress_host with dynamic hostname
      if [ "${TF_ENVIRONMENT:-}" = "review" ] && [ -n "${CI_COMMIT_REF_SLUG:-}" ]; then
        DYNAMIC_INGRESS_HOST="${FIXED_SUBDOMAIN:-attic-cache}-${CI_COMMIT_REF_SLUG}.${KUBE_INGRESS_BASE_DOMAIN}"
        echo "Using dynamic ingress host for review: ${DYNAMIC_INGRESS_HOST}"
        VAR_FLAGS+=(-var="ingress_host=${DYNAMIC_INGRESS_HOST}")
      fi

      # Pass kubeconfig path to OpenTofu provider
      # GitLab CI sets KUBECONFIG env var when using Kubernetes Agent
      if [ -n "${KUBECONFIG:-}" ]; then
        echo "Using KUBECONFIG: ${KUBECONFIG}"
        VAR_FLAGS+=(-var="k8s_config_path=${KUBECONFIG}")
      fi

      # Only pass database_url if ATTIC_DATABASE_URL is set and non-empty
      # With use_cnpg_postgres=true, the URL is generated by CloudNativePG
      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      tofu plan "${VAR_FLAGS[@]}" -out=tfplan

      echo ""
      echo "Plan summary:"
      tofu show -no-color tfplan | tee plan-output.txt

      # Generate JSON plan for MR comments
      tofu show -json tfplan > plan.json

  artifacts:
    paths:
      - tofu/stacks/attic/tfplan
      - tofu/stacks/attic/plan-output.txt
      - tofu/stacks/attic/plan.json
      - tofu/stacks/attic/.terraform/
      - tofu/stacks/attic/.terraform.lock.hcl
    reports:
      # Use JSON format for proper MR widget integration
      # Shows resource add/change/destroy counts in MR
      terraform: tofu/stacks/attic/plan.json
    expire_in: 7 days
    # Restrict access to plan files (may contain sensitive data)
    access: developer

# Plan for review environments (dev cluster)
tofu:plan:review:
  extends: .tofu_plan_base
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  variables:
    TF_STATE_NAME: "attic-review"
    TF_ENVIRONMENT: "review"
    TF_VAR_namespace: "attic-cache-review"
    TF_VAR_environment: "development"
    TF_VAR_tfvars_file: "beehive.tfvars"
    KUBE_CONTEXT: $REVIEW_CLUSTER_CONTEXT
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: prepare

# Plan for staging (prod cluster)
tofu:plan:staging:
  extends: .tofu_plan_base
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  variables:
    TF_STATE_NAME: "attic-staging"
    TF_ENVIRONMENT: "staging"
    TF_VAR_namespace: "attic-cache-staging"
    TF_VAR_environment: "staging"
    TF_VAR_tfvars_file: "prod.tfvars"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  environment:
    name: staging
    action: prepare

# Plan for production (prod cluster, semver tags)
tofu:plan:production:
  extends: .tofu_plan_base
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+/
  variables:
    TF_STATE_NAME: "attic-production"
    TF_ENVIRONMENT: "production"
    TF_VAR_namespace: "attic-cache"
    TF_VAR_environment: "production"
    TF_VAR_tfvars_file: "prod.tfvars"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  environment:
    name: production
    action: prepare

# ==============================================================================
# Drift Detection Job
# ==============================================================================
#
# Runs on schedule to detect configuration drift between
# the deployed infrastructure and the IaC code.
# Schedule: Daily at 6am UTC (configure in GitLab CI/CD > Schedules)

tofu:drift-detection:
  extends: .tofu_with_k8s_tools
  stage: verify
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  variables:
    TF_STATE_NAME: "attic-production"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  script:
    - |
      echo "=== Infrastructure Drift Detection ==="
      cd tofu/stacks/attic

      # Configure GitLab state backend
      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      echo "Initializing OpenTofu..."
      tofu init

      echo ""
      echo "Checking for drift..."

      # Build var flags for deployment
      VAR_FLAGS=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=attic-cache"
        -var="environment=production"
        -var="use_cnpg_postgres=true"
        -var-file="prod.tfvars"
      )

      # Pass kubeconfig path to OpenTofu provider
      if [ -n "${KUBECONFIG:-}" ]; then
        echo "Using KUBECONFIG: ${KUBECONFIG}"
        VAR_FLAGS+=(-var="k8s_config_path=${KUBECONFIG}")
      fi

      # Only pass S3 vars if MinIO is disabled
      if grep -q 'use_minio.*=.*true' "prod.tfvars"; then
        echo "MinIO enabled - S3 variables not required"
      else
        VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      # Run plan with detailed exit code
      # Exit code 0 = no changes, 1 = error, 2 = changes detected
      DRIFT_STATUS=0
      tofu plan "${VAR_FLAGS[@]}" -detailed-exitcode -out=drift-plan || DRIFT_STATUS=$?

      if [ $DRIFT_STATUS -eq 0 ]; then
        echo ""
        echo "No drift detected - infrastructure matches configuration"
      elif [ $DRIFT_STATUS -eq 2 ]; then
        echo ""
        echo "DRIFT DETECTED - Infrastructure differs from configuration!"
        echo ""
        echo "Changes that would be applied:"
        tofu show -no-color drift-plan | tee drift-report.txt
        echo ""
        echo "Review the drift report and consider applying changes."
        exit 1
      else
        echo ""
        echo "ERROR: Plan failed with exit code $DRIFT_STATUS"
        exit 1
      fi
  artifacts:
    when: on_failure
    paths:
      - tofu/stacks/attic/drift-report.txt
    expire_in: 7 days
  allow_failure: true

# ==============================================================================
# Security Scanning Job
# ==============================================================================
#
# Uses Trivy to scan OpenTofu code for security issues.

tofu:security-scan:
  stage: validate
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - echo "=== OpenTofu Security Scan ==="
    - echo "Scanning with Trivy..."
    - trivy config tofu/ --format json --output trivy-report.json || true
    - trivy config tofu/ --format table | tee trivy-output.txt || true
    - echo ""
    - echo "Scan complete. See artifacts for details."
  artifacts:
    paths:
      - trivy-report.json
      - trivy-output.txt
    expire_in: 7 days
  allow_failure: true
