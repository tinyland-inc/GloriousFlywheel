# Nix Build Jobs
# ==============
#
# These jobs build Nix packages and push them to the Attic cache.
# Uses Alpine with Nix installed via DeterminateSystems installer since
# nixos/nix images lack /bin/sh required by GitLab Runner.
#
# Cache flywheel:
#   1. Pull: Attic configured as substituter (before_script)
#   2. Incremental push: watch-store streams each derivation to cache as it's built
#   3. Final push: closure push of result symlink (belt-and-suspenders)
#
# First pipeline (cold): watch-store skipped (attic client not cached yet).
#   End-of-build push populates cache with the full result.
# Subsequent pipelines: watch-store active. Even partial/failed builds
#   cache their intermediate derivations (rustc, cargo deps, nix libs).

.nix-build-base:
  stage: build
  image: alpine:3.21
  tags:
    - nix
  interruptible: true
  timeout: 90 minutes
  before_script:
    - apk add --no-cache curl xz bash git
    # Fix /nix permissions (runner mounts emptyDir which is world-writable)
    - chmod 755 /nix 2>/dev/null || true
    - curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install linux --no-confirm --init none
    - . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
    - nix --version
    # Dogfood: use our Attic cache as a substituter (pull cached builds)
    # Adds both stable and review URLs — nix silently skips unreachable ones
    - |
      CACHE_NAME="${ATTIC_CACHE:-main}"
      if [ -n "${ATTIC_SERVER:-}" ]; then
        echo "Configuring Attic substituter: ${ATTIC_SERVER}/${CACHE_NAME}"
        echo "extra-substituters = ${ATTIC_SERVER}/${CACHE_NAME}" >> /etc/nix/nix.conf
        echo "trusted-substituters = ${ATTIC_SERVER}/${CACHE_NAME}" >> /etc/nix/nix.conf
      fi
      if [ -n "${CI_COMMIT_REF_SLUG:-}" ]; then
        REVIEW_URL="https://${FIXED_SUBDOMAIN:-attic-cache}-${CI_COMMIT_REF_SLUG}.${KUBE_INGRESS_BASE_DOMAIN}/${CACHE_NAME}"
        echo "Also trying review cache: ${REVIEW_URL}"
        echo "extra-substituters = ${REVIEW_URL}" >> /etc/nix/nix.conf
        echo "trusted-substituters = ${REVIEW_URL}" >> /etc/nix/nix.conf
      fi
    # Discover reachable Attic server and start incremental cache push
    - |
      ATTIC_PUSH_SERVER=""
      if [ -n "${CI_COMMIT_REF_SLUG:-}" ]; then
        REVIEW_SERVER="https://${FIXED_SUBDOMAIN:-attic-cache}-${CI_COMMIT_REF_SLUG}.${KUBE_INGRESS_BASE_DOMAIN}"
        if curl -sSf "${REVIEW_SERVER}/" --connect-timeout 5 --max-time 10 >/dev/null 2>&1; then
          ATTIC_PUSH_SERVER="${REVIEW_SERVER}"
        fi
      fi
      if [ -z "$ATTIC_PUSH_SERVER" ] && [ -n "${ATTIC_SERVER:-}" ]; then
        if curl -sSf "${ATTIC_SERVER}/" --connect-timeout 5 --max-time 10 >/dev/null 2>&1; then
          ATTIC_PUSH_SERVER="${ATTIC_SERVER}"
        fi
      fi
      echo "$ATTIC_PUSH_SERVER" > /tmp/attic-push-server

      if [ -n "$ATTIC_PUSH_SERVER" ]; then
        # Bootstrap attic client from cache (--max-jobs 0 = substituters only, no local builds)
        # First pipeline: fails fast (not cached yet), watch-store skipped
        # Subsequent pipelines: fast pull from cache, watch-store streams incrementally
        if nix build .#attic-client --out-link /tmp/attic-client --max-jobs 0 2>/dev/null; then
          /tmp/attic-client/bin/attic login --set-default ci "$ATTIC_PUSH_SERVER" || true
          echo "Starting watch-store (incremental cache push)..."
          /tmp/attic-client/bin/attic watch-store "${ATTIC_CACHE:-main}" >> /tmp/attic-watch.log 2>&1 &
          echo $! > /tmp/attic-watch.pid
          echo "watch-store running (PID: $(cat /tmp/attic-watch.pid))"
        else
          echo "Attic client not cached yet — watch-store skipped (first build bootstraps cache)"
        fi
      else
        echo "No reachable Attic server — cache push disabled"
      fi
  after_script:
    # Clean up watch-store and show push summary
    - |
      if [ -f /tmp/attic-watch.pid ]; then
        PID=$(cat /tmp/attic-watch.pid)
        kill "$PID" 2>/dev/null; wait "$PID" 2>/dev/null || true
        PUSHED=$(grep -c "Pushing\|pushed" /tmp/attic-watch.log 2>/dev/null || echo 0)
        echo "watch-store pushed ${PUSHED} store paths incrementally"
        tail -5 /tmp/attic-watch.log 2>/dev/null || true
      fi
  artifacts:
    paths:
      - result*
    expire_in: 1 day

# Build Attic client
nix:build-client:
  extends: .nix-build-base
  needs: [] # Greedy: run immediately, don't wait for validate stage
  allow_failure: true
  script:
    - echo "Building Attic client..."
    - nix build .#attic-client --print-build-logs --out-link result-client
    - |
      # Final closure push (watch-store handles incrementals; this seals the result)
      SERVER=$(cat /tmp/attic-push-server 2>/dev/null)
      if [ -n "$SERVER" ]; then
        if [ -x /tmp/attic-client/bin/attic ]; then
          /tmp/attic-client/bin/attic push "${ATTIC_CACHE:-main}" result-client || echo "WARNING: Cache push failed (non-blocking)"
        else
          # First build: use the client we just built
          result-client/bin/attic login --set-default ci "$SERVER" || true
          result-client/bin/attic push "${ATTIC_CACHE:-main}" result-client || echo "WARNING: Cache push failed (non-blocking)"
        fi
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build Attic server container image
nix:build-container:
  extends: .nix-build-base
  needs: [] # Greedy: run immediately
  allow_failure: true
  script:
    - echo "Building Attic server container..."
    - nix build .#container --print-build-logs --out-link result-container
    - |
      # Build the copyTo script for pushing to registries
      echo "Building container push script..."
      nix build '.#container.copyTo' --out-link result-copy-to
    - |
      if [ -e result-container ]; then
        echo "Container image manifest built successfully"
        cat result-container | head -20
      fi
    - |
      # Final closure push
      SERVER=$(cat /tmp/attic-push-server 2>/dev/null)
      if [ -n "$SERVER" ] && [ -x /tmp/attic-client/bin/attic ]; then
        /tmp/attic-client/bin/attic push "${ATTIC_CACHE:-main}" result-container || echo "WARNING: Cache push failed (non-blocking)"
      elif [ -n "$SERVER" ]; then
        nix run .#attic -- login --set-default ci "$SERVER" || true
        nix run .#attic -- push "${ATTIC_CACHE:-main}" result-container || echo "WARNING: Cache push failed (non-blocking)"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build GC image
nix:build-gc-image:
  extends: .nix-build-base
  needs: [] # Greedy: run immediately
  allow_failure: true
  script:
    - echo "Building Attic GC container..."
    - nix build .#attic-gc-image --print-build-logs --out-link result-gc
    - |
      # Final closure push
      SERVER=$(cat /tmp/attic-push-server 2>/dev/null)
      if [ -n "$SERVER" ] && [ -x /tmp/attic-client/bin/attic ]; then
        /tmp/attic-client/bin/attic push "${ATTIC_CACHE:-main}" result-gc || echo "WARNING: Cache push failed (non-blocking)"
      elif [ -n "$SERVER" ]; then
        nix run .#attic -- login --set-default ci "$SERVER" || true
        nix run .#attic -- push "${ATTIC_CACHE:-main}" result-gc || echo "WARNING: Cache push failed (non-blocking)"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Push container to registry
# Rebuilds copyTo script here because GitLab artifacts are symlinks to nix
# store paths that don't exist in the push job's environment. Fast when cached.
nix:push-container:
  extends: .nix-build-base
  stage: deploy
  allow_failure: true
  needs:
    - job: nix:build-container
      optional: true
  script:
    - echo "Pushing container to registry..."
    - |
      if [ -n "${CI_REGISTRY:-}" ] && [ -n "${CI_REGISTRY_USER:-}" ]; then
        echo "Building container copy-to script..."
        nix build '.#container.copyTo' --out-link result-copy-to

        COPY_TO="./result-copy-to/bin/copy-to"

        if [ ! -x "$COPY_TO" ]; then
          echo "ERROR: copyTo script build failed"
          exit 1
        fi

        DEST_CREDS="--dest-creds=${CI_REGISTRY_USER}:${CI_REGISTRY_PASSWORD}"

        echo "Pushing image: ${CI_REGISTRY_IMAGE}/attic-server:${CI_COMMIT_SHORT_SHA}"
        "$COPY_TO" "docker://${CI_REGISTRY_IMAGE}/attic-server:${CI_COMMIT_SHORT_SHA}" "$DEST_CREDS"

        echo "Pushing image: ${CI_REGISTRY_IMAGE}/attic-server:latest"
        "$COPY_TO" "docker://${CI_REGISTRY_IMAGE}/attic-server:latest" "$DEST_CREDS"

        echo "Successfully pushed container images"
      else
        echo "SKIP: Container registry not configured"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: https://attic-cache.${STAGING_INGRESS_DOMAIN}

# Full build with all outputs (tags + scheduled)
nix:build-all:
  extends: .nix-build-base
  script:
    - echo "Building all flake outputs..."
    - nix build .#attic-client --out-link result-client
    - nix build .#attic-server --out-link result-server
    - nix build .#container --out-link result-container
    - nix build .#attic-gc-image --out-link result-gc
    - |
      echo "Build summary:"
      ls -la result-*
    - |
      # Final closure push for all results
      SERVER=$(cat /tmp/attic-push-server 2>/dev/null)
      if [ -n "$SERVER" ] && [ -x /tmp/attic-client/bin/attic ]; then
        /tmp/attic-client/bin/attic push "${ATTIC_CACHE:-main}" result-* || echo "WARNING: Cache push failed (non-blocking)"
      elif [ -n "$SERVER" ]; then
        nix run .#attic -- login --set-default ci "$SERVER" || true
        nix run .#attic -- push "${ATTIC_CACHE:-main}" result-* || echo "WARNING: Cache push failed (non-blocking)"
      fi
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "schedule"
