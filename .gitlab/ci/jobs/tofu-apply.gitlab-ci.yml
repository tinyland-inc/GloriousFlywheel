# OpenTofu Apply Jobs
#
# Applies infrastructure changes to Kubernetes clusters.
# - Review: Auto-deploy MRs to dev cluster
# - Staging: Auto-deploy on main branch to prod cluster
# - Production: Auto-deploy on semver tags to prod cluster
#
# Uses auth-free mode with GitLab K8s Agent

# ==============================================================================
# Base Apply Template (GitLab K8s Agent)
# ==============================================================================

.tofu_apply_base:
  extends: .tofu_with_k8s_tools
  stage: deploy
  script:
    - |
      echo "=== OpenTofu Apply (${TF_ENVIRONMENT}) ==="
      cd tofu/stacks/attic

      # Configure GitLab state backend
      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      echo "State: ${TF_HTTP_ADDRESS}"
      echo "Environment: ${TF_ENVIRONMENT}"
      echo "Namespace: ${TF_VAR_namespace}"
      echo "Cluster: ${KUBE_CONTEXT}"

      echo ""
      echo "Initializing OpenTofu..."
      tofu init

      # Load environment-specific tfvars file path
      VAR_FILE="${TF_VAR_tfvars_file:-beehive.tfvars}"

      # Build var flags: var-file FIRST, then explicit -var flags override
      # This allows CI variables to override tfvars defaults
      VAR_FLAGS=()

      # Load environment-specific tfvars FIRST (so -var can override)
      if [ -f "$VAR_FILE" ]; then
        echo "Loading $VAR_FILE"
        VAR_FLAGS+=(-var-file="$VAR_FILE")
      fi

      # Only pass S3 vars if MinIO is disabled (check tfvars)
      # When use_minio=true, MinIO provides S3-compatible storage internally
      if [ -f "$VAR_FILE" ] && grep -q 'use_minio.*=.*true' "$VAR_FILE"; then
        echo "MinIO enabled - S3 variables not required"
      else
        echo "External S3 mode - passing S3 variables"
        VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      # Explicit -var flags AFTER var-file (these override tfvars)
      VAR_FLAGS+=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=${TF_VAR_namespace:-attic-cache}"
        -var="environment=${TF_VAR_environment:-production}"
        -var="use_cnpg_postgres=true"
        -var="deploy_version=${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}"
      )

      # For review environments, override ingress_host with dynamic hostname
      if [ "${TF_ENVIRONMENT:-}" = "review" ] && [ -n "${CI_COMMIT_REF_SLUG:-}" ]; then
        DYNAMIC_INGRESS_HOST="${FIXED_SUBDOMAIN:-attic-cache}-${CI_COMMIT_REF_SLUG}.${KUBE_INGRESS_BASE_DOMAIN}"
        echo "Using dynamic ingress host for review: ${DYNAMIC_INGRESS_HOST}"
        VAR_FLAGS+=(-var="ingress_host=${DYNAMIC_INGRESS_HOST}")
      fi

      # Pass kubeconfig path to OpenTofu provider
      # GitLab CI sets KUBECONFIG env var when using Kubernetes Agent
      if [ -n "${KUBECONFIG:-}" ]; then
        echo "Using KUBECONFIG: ${KUBECONFIG}"
        VAR_FLAGS+=(-var="k8s_config_path=${KUBECONFIG}")
      fi

      # Only pass database_url if ATTIC_DATABASE_URL is set and non-empty
      # With use_cnpg_postgres=true, the URL is generated by CloudNativePG
      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      # Adopt pre-existing cluster resources if state is empty
      # Strategy: import shared operators, clean stale app namespace, let tofu recreate
      if ! tofu state list 2>/dev/null | grep -q .; then
        echo ""
        echo "Empty state detected — adopting pre-existing resources..."
        NS="${TF_VAR_namespace:-attic-cache}"

        # 1. Import shared operator resources (persist across environments)
        if kubectl get namespace cnpg-system >/dev/null 2>&1; then
          echo "  Importing cnpg-system namespace"
          tofu import "${VAR_FLAGS[@]}" 'module.cnpg_operator[0].kubernetes_namespace.cnpg_system[0]' cnpg-system || true
        fi
        if kubectl get secret -n minio-operator -l owner=helm,name=minio-operator >/dev/null 2>&1; then
          echo "  Importing minio-operator helm release"
          tofu import "${VAR_FLAGS[@]}" 'module.minio_operator[0].helm_release.minio_operator[0]' minio-operator/minio-operator || true
        fi
        if kubectl get secret -n cnpg-system -l owner=helm,name=cnpg >/dev/null 2>&1; then
          echo "  Importing CNPG helm release"
          tofu import "${VAR_FLAGS[@]}" 'module.cnpg_operator[0].helm_release.cnpg' cnpg-system/cnpg || true
        fi

        # 2. Delete stale app namespace so tofu can create fresh
        #    Review environments are ephemeral — no data loss concern
        if kubectl get namespace "$NS" >/dev/null 2>&1; then
          echo ""
          echo "  Deleting stale app namespace $NS for clean deployment..."
          kubectl delete namespace "$NS" --wait=true --timeout=120s || true
          echo "  Namespace deleted"
        fi

        echo "  Adoption phase complete"
      fi

      # Refresh state to sync any external changes or imports
      echo ""
      echo "Refreshing state from remote backend..."
      tofu refresh "${VAR_FLAGS[@]}" -lock-timeout=5m

      # Dry-run validation before apply
      echo ""
      echo "Running plan validation..."
      tofu plan "${VAR_FLAGS[@]}" -detailed-exitcode || PLAN_EXIT=$?

      # Exit code 0 = no changes, 1 = error, 2 = changes pending
      if [ "${PLAN_EXIT:-0}" -eq 1 ]; then
        echo "ERROR: Plan validation failed"
        exit 1
      fi

      echo ""
      echo "Applying infrastructure..."
      tofu apply -auto-approve "${VAR_FLAGS[@]}"

      echo ""
      echo "Outputs:"
      tofu output

      echo ""
      echo "Verifying deployment..."
      NAMESPACE=$(tofu output -raw namespace)
      DEPLOYMENT=$(tofu output -raw deployment_name)

      # Wait for rollout (non-blocking - dependencies may still be initializing)
      if ! kubectl rollout status deployment/${DEPLOYMENT} -n ${NAMESPACE} --timeout=300s; then
        echo "WARNING: Rollout not complete within timeout (dependencies may still be initializing)"
        echo "The deployment will become ready once PostgreSQL and MinIO are fully initialized"
        kubectl get pods -n ${NAMESPACE}
      fi

      # Health check gate
      echo ""
      echo "Running health check..."
      HEALTH_URL="${DEPLOY_URL}/nix-cache-info"
      for i in 1 2 3 4 5; do
        echo "Health check attempt ${i}/5..."
        if curl -sSf "${HEALTH_URL}" --connect-timeout 10 --max-time 30; then
          echo ""
          echo "Health check passed"
          break
        fi
        if [ "$i" -eq 5 ]; then
          echo "WARNING: Health check failed after 5 attempts"
          echo "Deployment may need manual verification"
        fi
        sleep 10
      done

      echo ""
      echo "Deployment successful"
      kubectl get pods -n ${NAMESPACE}

      # Verify HPA is scaling correctly
      echo ""
      echo "HPA Status:"
      kubectl get hpa -n ${NAMESPACE}

# ==============================================================================
# Review Deployment - Auto on MRs (dev cluster)
# ==============================================================================

tofu:apply:review:
  extends: .tofu_apply_base
  needs:
    - job: tofu:plan:review
      artifacts: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  variables:
    # Single shared state — all MR branches deploy to the same review namespace
    # and shared cluster resources (cnpg-system, minio-operator)
    TF_STATE_NAME: "attic-review"
    TF_ENVIRONMENT: "review"
    TF_VAR_namespace: "attic-cache-review"
    TF_VAR_environment: "development"
    TF_VAR_tfvars_file: "beehive.tfvars"
    KUBE_CONTEXT: $REVIEW_CLUSTER_CONTEXT
    DEPLOY_URL: "https://attic-cache-${CI_COMMIT_REF_SLUG}.${REVIEW_INGRESS_DOMAIN}"
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    url: https://attic-cache-${CI_COMMIT_REF_SLUG}.${REVIEW_INGRESS_DOMAIN}
    on_stop: tofu:destroy:review
    auto_stop_in: 1 week

# ==============================================================================
# Staging Deployment - Auto on main branch (prod cluster)
# ==============================================================================

# NOTE: No dependency on nix build jobs - infrastructure deployment doesn't
# require the container builds to complete. Apply starts immediately after plan.
tofu:apply:staging:
  extends: .tofu_apply_base
  needs:
    - job: tofu:plan:staging
      artifacts: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  variables:
    TF_STATE_NAME: "attic-staging"
    TF_ENVIRONMENT: "staging"
    TF_VAR_namespace: "attic-cache-staging"
    TF_VAR_environment: "staging"
    TF_VAR_tfvars_file: "prod.tfvars"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
    DEPLOY_URL: "https://attic-cache-staging.${STAGING_INGRESS_DOMAIN}"
  environment:
    name: staging
    url: https://attic-cache-staging.${STAGING_INGRESS_DOMAIN}
    on_stop: tofu:destroy:staging
    auto_stop_in: 1 week

# ==============================================================================
# Production Deployment - Auto on semver tags (prod cluster)
# ==============================================================================

# NOTE: No dependency on nix build jobs - infrastructure deployment doesn't
# require the container builds to complete.
tofu:apply:production:
  extends: .tofu_apply_base
  needs:
    - job: tofu:plan:production
      artifacts: true
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+/
  variables:
    TF_STATE_NAME: "attic-production"
    TF_ENVIRONMENT: "production"
    TF_VAR_namespace: "attic-cache"
    TF_VAR_environment: "production"
    TF_VAR_tfvars_file: "prod.tfvars"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
    DEPLOY_URL: "https://attic-cache.${STAGING_INGRESS_DOMAIN}"
  environment:
    name: production
    url: https://attic-cache.${STAGING_INGRESS_DOMAIN}
    deployment_tier: production

# ==============================================================================
# Manual Production Deploy (for main branch)
# ==============================================================================

tofu:apply:production:manual:
  extends: .tofu_apply_base
  needs:
    - job: tofu:plan:staging
      artifacts: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  variables:
    TF_STATE_NAME: "attic-production"
    TF_ENVIRONMENT: "production"
    TF_VAR_namespace: "attic-cache"
    TF_VAR_environment: "production"
    TF_VAR_tfvars_file: "prod.tfvars"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
    DEPLOY_URL: "https://attic-cache.${STAGING_INGRESS_DOMAIN}"
  environment:
    name: production
    url: https://attic-cache.${STAGING_INGRESS_DOMAIN}

# ==============================================================================
# Feature Branch Deployment (Plan Only)
# ==============================================================================

# ==============================================================================
# Rollback Job
# ==============================================================================

tofu:rollback:
  extends: .tofu_with_k8s_tools
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-production"
    ROLLBACK_NAMESPACE: "attic-cache"
    ROLLBACK_DEPLOYMENT: "attic"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  script:
    - |
      echo "=== Rollback Deployment ==="
      echo ""

      if [ -z "${ROLLBACK_IMAGE:-}" ]; then
        echo "Fetching available images for rollback..."
        echo ""

        # Get deployment history
        echo "Deployment revision history:"
        kubectl rollout history deployment/${ROLLBACK_DEPLOYMENT} -n ${ROLLBACK_NAMESPACE}

        echo ""
        echo "Current pod images:"
        kubectl get pods -n ${ROLLBACK_NAMESPACE} -l app.kubernetes.io/name=${ROLLBACK_DEPLOYMENT} \
          -o jsonpath='{range .items[*]}{.metadata.name}: {.spec.containers[0].image}{"\n"}{end}'

        echo ""
        echo "To perform rollback, re-run this job with ROLLBACK_IMAGE variable set:"
        echo "  ROLLBACK_IMAGE=heywoodlh/attic:v0.1.x"
        echo ""
        echo "Or use kubectl rollback:"
        echo "  kubectl rollout undo deployment/${ROLLBACK_DEPLOYMENT} -n ${ROLLBACK_NAMESPACE}"
        exit 0
      fi

      echo "Rolling back to image: ${ROLLBACK_IMAGE}"
      echo ""

      # Perform rollback via image update
      kubectl set image deployment/${ROLLBACK_DEPLOYMENT} \
        attic=${ROLLBACK_IMAGE} \
        -n ${ROLLBACK_NAMESPACE}

      # Wait for rollout
      echo ""
      echo "Waiting for rollback to complete..."
      kubectl rollout status deployment/${ROLLBACK_DEPLOYMENT} -n ${ROLLBACK_NAMESPACE} --timeout=300s

      echo ""
      echo "Rollback complete. Current state:"
      kubectl get pods -n ${ROLLBACK_NAMESPACE} -l app.kubernetes.io/name=${ROLLBACK_DEPLOYMENT}

      # Health check
      echo ""
      echo "Running health check..."
      HEALTH_URL="https://attic-cache.${STAGING_INGRESS_DOMAIN}/nix-cache-info"
      for i in 1 2 3; do
        if curl -sSf "${HEALTH_URL}" --connect-timeout 10 --max-time 30; then
          echo ""
          echo "Rollback verified - service is healthy"
          exit 0
        fi
        sleep 10
      done

      echo "WARNING: Health check failed - manual verification required"

  environment:
    name: production
    action: access

# ==============================================================================
# Staging Rollback
# ==============================================================================

tofu:rollback:staging:
  extends: tofu:rollback
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-staging"
    ROLLBACK_NAMESPACE: "attic-cache-staging"
    ROLLBACK_DEPLOYMENT: "attic"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  environment:
    name: staging
    action: access

# ==============================================================================
# Review Rollback
# ==============================================================================

tofu:rollback:review:
  extends: tofu:rollback
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-review"
    ROLLBACK_NAMESPACE: "attic-cache-review"
    ROLLBACK_DEPLOYMENT: "attic"
    KUBE_CONTEXT: $REVIEW_CLUSTER_CONTEXT
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: access

# ==============================================================================
# Destroy Jobs
# ==============================================================================

# Destroy review environment
tofu:destroy:review:
  extends: .tofu_with_k8s_tools
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-review"
    KUBE_CONTEXT: $REVIEW_CLUSTER_CONTEXT
  script:
    - |
      echo "=== OpenTofu Destroy (Review) ==="
      cd tofu/stacks/attic

      # Configure GitLab state backend
      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      echo "WARNING: Destroying review environment"

      tofu init

      # Build var flags for deployment
      DESTROY_VAR_FLAGS=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=attic-cache-review"
        -var="environment=development"
        -var="use_cnpg_postgres=true"
        -var-file="beehive.tfvars"
      )

      # Only pass S3 vars if MinIO is disabled
      if grep -q 'use_minio.*=.*true' "beehive.tfvars"; then
        echo "MinIO enabled - S3 variables not required"
      else
        DESTROY_VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        DESTROY_VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      tofu destroy -auto-approve "${DESTROY_VAR_FLAGS[@]}"

      echo "Review environment destroyed"

  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop

# Destroy staging environment
tofu:destroy:staging:
  extends: .tofu_with_k8s_tools
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-staging"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  script:
    - |
      echo "=== OpenTofu Destroy (Staging) ==="
      cd tofu/stacks/attic

      # Configure GitLab state backend
      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      echo "WARNING: Destroying staging environment"

      tofu init

      # Build var flags for deployment
      DESTROY_VAR_FLAGS=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=attic-cache-staging"
        -var="environment=staging"
        -var="use_cnpg_postgres=true"
        -var-file="prod.tfvars"
      )

      # Only pass S3 vars if MinIO is disabled
      if grep -q 'use_minio.*=.*true' "prod.tfvars"; then
        echo "MinIO enabled - S3 variables not required"
      else
        DESTROY_VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        DESTROY_VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      tofu destroy -auto-approve "${DESTROY_VAR_FLAGS[@]}"

      echo "Staging environment destroyed"

  environment:
    name: staging
    action: stop

# Production destroy (dangerous, requires confirmation)
tofu:destroy:production:
  extends: .tofu_with_k8s_tools
  stage: deploy
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $DESTROY_PRODUCTION == "true"
      when: manual
      allow_failure: true
  variables:
    TF_STATE_NAME: "attic-production"
    KUBE_CONTEXT: $STAGING_CLUSTER_CONTEXT
  script:
    - |
      echo "=== OpenTofu Destroy (PRODUCTION) ==="
      echo ""
      echo "!!! WARNING: THIS WILL DESTROY PRODUCTION INFRASTRUCTURE !!!"
      echo ""

      if [ "$CONFIRM_DESTROY" != "yes-destroy-production" ]; then
        echo "ERROR: Confirmation required"
        echo "Set CONFIRM_DESTROY=yes-destroy-production to proceed"
        exit 1
      fi

      cd tofu/stacks/attic

      export TF_HTTP_ADDRESS="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${TF_STATE_NAME}"
      export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
      export TF_HTTP_LOCK_METHOD="POST"
      export TF_HTTP_UNLOCK_METHOD="DELETE"
      export TF_HTTP_USERNAME="gitlab-ci-token"
      export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"

      tofu init

      # Build var flags for deployment
      DESTROY_VAR_FLAGS=(
        -var="cluster_context=${KUBE_CONTEXT}"
        -var="namespace=attic-cache"
        -var="environment=production"
        -var="use_cnpg_postgres=true"
        -var-file="prod.tfvars"
      )

      # Only pass S3 vars if MinIO is disabled
      if grep -q 'use_minio.*=.*true' "prod.tfvars"; then
        echo "MinIO enabled - S3 variables not required"
      else
        DESTROY_VAR_FLAGS+=(
          -var="s3_endpoint=${S3_ENDPOINT:-}"
          -var="s3_bucket_name=${S3_BUCKET_NAME:-}"
          -var="s3_access_key_id=${S3_ACCESS_KEY_ID:-}"
          -var="s3_secret_access_key=${S3_SECRET_ACCESS_KEY:-}"
        )
      fi

      if [ -n "${ATTIC_DATABASE_URL:-}" ]; then
        DESTROY_VAR_FLAGS+=(-var="database_url=${ATTIC_DATABASE_URL}")
      fi

      tofu destroy -auto-approve "${DESTROY_VAR_FLAGS[@]}"

      echo "Production environment destroyed"

  environment:
    name: production
    action: stop
